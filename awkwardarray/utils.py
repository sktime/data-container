from awkward import IndexedArray, JaggedArray
from scipy.ndimage.interpolation import shift
import pandas as pd
import numpy as np


def awkward_build(data_frame: pd.DataFrame) -> JaggedArray:
    """Builds an Awkward Array from a nested DataFrame.
    """
    num_cases = len(data_frame)
    cases = [None] * num_cases

    for case_num in np.arange(num_cases):
        case = data_frame.iloc[case_num, :]
        case_len = len(case)
        features = [None] * case_len

        for feature_num in np.arange(case_len):
            numpy_array = case.iloc[feature_num]
            array_size = numpy_array.shape[0]
            indexed_array = IndexedArray(np.arange(array_size), numpy_array)
            features[feature_num] = indexed_array

        cases[case_num] = JaggedArray.fromiter(features)

    return JaggedArray.fromiter(cases)


def awkward_tabularize(jagged_array: JaggedArray) -> JaggedArray:
    """Tabularises a 2-D JaggedArray of sub-arrays.

    Parameters
    ----------
    jagged_array : JaggedArray
        The array that should be tabularised.

    Returns
    -------
    JaggedArray
        jagged_array tabularised.
    """
    return jagged_array.flatten()


def awkward_detabularize(x: JaggedArray, content_counts: np.ndarray, counts: np.ndarray) -> JaggedArray:
    """Detabularises an generated by awkward_tabularize().

    Parameters
    ----------
    x : JaggedArray
        The array generated by awkward_tabularize().

    content_counts : np.ndarray
        The array of counts for the content array for the array to return.

    counts : np.ndarray
        The array of counts for the array to return.

    Returns
    -------
    JaggedArray
        x detabularised.
    """
    content_array = JaggedArray.fromcounts(content_counts, x.flatten())
    return JaggedArray.fromcounts(counts, content_array)


def awkward_generate_index(jagged_array: JaggedArray) -> JaggedArray:
    """Gets an array of integers giving the index values for the sub-arrays of a specified Awkward Array.

    Parameters
    ----------
    jagged_array : JaggedArray
        The 2-D array whose sub-arrays that index values should be returned for.

    Returns
    -------
        A 2-D array who sub-arrays contain integers giving the index values for the sub-arrays of jagged_array.
    """
    index_array = jagged_array.ones_like()
    index_array.content.content = np.cumsum(index_array.content.content) - 1

    subtraction_array = np.cumsum(shift(index_array.count().content, 1, cval=0))
    index_array.content = index_array.content - subtraction_array

    return index_array


def awkward_slope_func(jagged_array: JaggedArray) -> JaggedArray:
    """Calculates the linear slope for a specified Jagged Array.

    Parameters
    ----------
    jagged_array : JaggedArray
        The 2-D array whose sub-arrays that slope values should be returned for.

    Returns
    -------
    JaggedArray
        A 2-D array of slope values for jagged_array.
    """
    x = awkward_generate_index(jagged_array)
    y = jagged_array

    n = x.count()
    sum_x = x.sum()
    sum_x_x = (x ** 2).sum()
    sum_x_y = (x * y).sum()
    sum_y = y.sum()

    return (n * sum_x_y - sum_x * sum_y) / ((n * sum_x_x) - (sum_x * sum_x))


def awkward_arrays_differ(array_a: JaggedArray, array_b: JaggedArray, threshold: float) -> bool:
    """Determines if two specified Awkward arrays differ.

    Parameters
    ----------
    array_a : JaggedArray
        The 1st 2-D array whose sub-arrays should be compared.

    array_b : JaggedArray
        The 2nd 2-D array whose sub-arrays should be compared.

    threshold : float
        A float value giving the maximum value that array elements can differ before the arrays are considered different.

    Returns
    -------
    bool
        True if a pair of elements in array_a and array_b differ by more than threshold, False otherwise.
    """

    # Compare the types of the arrays and their content

    if type(array_a) != JaggedArray:
        return True

    if type(array_a) != type(array_b):
        return True

    if not isinstance(array_a.content, type(array_b.content)):
        return True

    # Compare the contents of the arrays

    try:
        array_diff = (array_a - array_b)
        array_diff_max = np.abs(array_diff.max())
        threshold_exceeded = (array_diff_max > threshold)

        if isinstance(threshold_exceeded, np.ndarray):
            return threshold_exceeded.any()

        elif isinstance(threshold_exceeded.content, np.ndarray):
            return threshold_exceeded.content.any()

        elif isinstance(threshold_exceeded.content, JaggedArray):
            if isinstance(threshold_exceeded.content.content, np.ndarray):
                return threshold_exceeded.content.content.any()

        # Cannot deal with these types of arguments

        raise ValueError("Unsupported argument types")

    except (ValueError, TypeError):
        # Only reason an Exception could be thrown is that dimensions are not compatible

        return True


def data_frames_differ(data_frame_a: pd.DataFrame, data_frame_b: pd.DataFrame, threshold: float) -> bool:
    """Determines if two specified DataFrames differ.

    Parameters
    ----------
    data_frame_a : pd.DataFrame
        The 1st DataFrame whose elements should be compared.

    data_frame_b : pd.DataFrame
        The 2nd DataFrame whose elements should be compared.

    threshold : float
        A float value giving the maximum value that array elements can differ before the arrays are considered different.

    Returns
    -------
    bool
        True if a pair of elements in array_a and array_b differ by more than threshold, False otherwise.
    """

    # Compare the types of the objects and their indexes

    if type(data_frame_a) != pd.DataFrame:
        return True

    if type(data_frame_a) != type(data_frame_b):
        return True

    if not data_frame_a.index.equals(data_frame_b.index):
        return True

    # We do not compare names as some functions generate dummy names instead of the originals names

    if data_frame_a.columns.size != data_frame_b.columns.size:
        return True

    # Compare the contents of the arrays

    try:
        num_cases = data_frame_a.index.size
        num_features = data_frame_a.columns.size

        for case_num in range(num_cases):
            for feature_num in range(num_features):
                # Get the features for the array and DataFrame

                data_frame_a_feature = data_frame_a.values[case_num, feature_num]
                data_frame_b_feature = data_frame_b.values[case_num, feature_num]

                if type(data_frame_a_feature) != pd.Series:
                    return True

                if type(data_frame_b_feature) != pd.Series:
                    return True

                # Examine the values of the features

                data_frame_a_feature = data_frame_a_feature.values
                data_frame_b_feature = data_frame_b_feature.values

                if type(data_frame_a_feature) != np.ndarray:
                    return True

                if type(data_frame_b_feature) != np.ndarray:
                    return True

                # Compare the features

                array_diff = (data_frame_a_feature - data_frame_b_feature)
                array_diff_max = np.abs(array_diff.max())

                if array_diff_max > threshold:
                    return True

        return False

    except (ValueError, TypeError):
        # Only reason an Exception could be thrown is that dimensions are not compatible

        return True


def awkward_array_data_frame_differ(array: JaggedArray, data_frame: pd.DataFrame, threshold: float, sub_arrays: bool = True) -> bool:
    """Determines if a specified Awkward Array and DataFrame differ.

    Parameters
    ----------
    array : JaggedArray
        The array whose sub-arrays should be compared.

    data_frame : pd.DataFrame
        The DataFrame whose elements should be compared.

    threshold : float
        A float value giving the maximum value that array elements can differ before the arrays are considered different.

    sub_arrays: bool
        True if array has sub-arrays, False otherwise.

    Returns
    -------
    bool
        True if a pair of elements in array_a and array_b differ by more than threshold, False otherwise.
    """

    # Compare the types of the objects and their indexes

    if type(array) != JaggedArray:
        return True

    if type(data_frame) != pd.DataFrame:
        return True

    if sub_arrays:
        if type(array.content) != JaggedArray:
            return True

        if type(array.content.content) != np.ndarray:
            return True
    else:
        if type(array.content) != np.ndarray:
            return True

    # Compare the number of cases

    array_len = len(array)
    data_frame_len = len(data_frame)

    if array_len != data_frame_len:
        return True

    # Compare the contents of the array and the DataFrame

    try:
        for case_num in range(array_len):
            # Get the cases for the array and DataFrame

            array_case = array[case_num]
            data_frame_case = data_frame.iloc[case_num, :]

            # Compare the number of features for each case

            array_num_features = len(array_case)
            data_frame_num_features = len(data_frame_case)

            if array_num_features != data_frame_num_features:
                return True

            # Examine the features

            for feature_num in range(array_num_features):
                # Get the features for the array and DataFrame

                array_feature = array_case[feature_num]
                data_frame_feature = data_frame_case.iloc[feature_num]

                # Examine the values of the features

                if sub_arrays:
                    if type(array_feature) != np.ndarray:
                        return True

                    if data_frame_num_features == 1:
                        if type(data_frame_feature.values) != np.ndarray:
                            return True
                        else:
                            data_frame_feature = data_frame_feature.values
                    else:
                        if type(data_frame_feature) != np.ndarray:
                            return True

                    array_diff = (array_feature - data_frame_feature)
                    array_diff_max = np.abs(array_diff.max())
                    threshold_exceeded = array_diff_max > threshold

                else:
                    diff = np.abs(array_feature - data_frame_feature)
                    threshold_exceeded = diff > threshold

                if threshold_exceeded:
                    return True

        return False

    except (ValueError, TypeError) as e:
        # Only reason an Exception could be thrown is that dimensions are not compatible

        return True


def awkward_generate_dummy_data() -> (JaggedArray, JaggedArray):
    """Generates a small amount of dummy data that can be used to clearly see the output of functions.

    Returns
    -------
    (JaggedArray, JaggedArray)
        A tuple containing 2 JaggedArrays.
        The 1st array is a 2-D array whose sub-arrays contain IndexedArray representing time series; cases are represented by the rows and features by the columns.
        The 2nd array contains the classification values (0 or 1) for each case.
    """
    x_tab_0 = IndexedArray([0, 1, 2], [0.0, 1.0, 2.0])
    x_tab_1 = IndexedArray([0, 1, 2], [1.0, 2.0, 3.0])
    x_tab_2 = IndexedArray([0, 1, 2], [2.0, 3.0, 4.0])
    x_tab_3 = IndexedArray([0, 1, 2], [3.0, 4.0, 5.0])

    y_tab_0 = IndexedArray([0, 1, 2], [4.0, 5.0, 6.0])
    y_tab_1 = IndexedArray([0, 1, 2], [5.0, 6.0, 7.0])
    y_tab_2 = IndexedArray([0, 1, 2], [6.0, 7.0, 8.0])
    y_tab_3 = IndexedArray([0, 1, 2], [6.0, 7.0, 8.0])

    case_0 = JaggedArray.fromiter([x_tab_0, y_tab_0])
    case_1 = JaggedArray.fromiter([x_tab_1, y_tab_1])
    case_2 = JaggedArray.fromiter([x_tab_2, y_tab_2])
    case_3 = JaggedArray.fromiter([x_tab_3, y_tab_3])

    y = JaggedArray.fromiter([0, 1, 1, 0])
    jagged_array = JaggedArray.fromiter([case_0, case_1, case_2, case_3])

    return jagged_array, y
